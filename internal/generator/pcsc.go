// Copyright 2023 The Happy Authors
// Licensed under the Apache License, Version 2.0.
// See the LICENSE file.

package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

func (g *Generator) pcsc() {
	var (
		sourceFilepath string
		destFilepath   string
		includePath    string
	)

	switch g.os {
	case "linux":
		includePath = "/usr/include/PCSC/"
		sourceFilepath = filepath.Join("pcsc", "const_c.go")
		destFilepath = filepath.Join("pcsc", "const.go")
	default:
		Fatal("pcsc unsupported os")
	}
	slog.Info("generating code for", slog.String("pkg", "github.com/happy-sdk/nfcsdk/pcsc"))

	cmd := exec.Command("go", "tool", "cgo", "-importpath", "github.com/happy-sdk/nfcsdk/pcsc", "-objdir", g.temp, "-godefs", "--", "-I", includePath, sourceFilepath)
	cmd.Dir = g.wd

	var cmdOut bytes.Buffer
	cmd.Stdout = &cmdOut

	if err := cmd.Run(); err != nil {
		Fatalf("pcsc command failed: %w", err)
	}

	if err := g.pcscAstErrors(cmdOut.String(), destFilepath); err != nil {
		Fatalf("pcsc command failed: %w", err)
	}

}

// pcscAstErrors generates error definitions for package
func (g *Generator) pcscAstErrors(src string, destFilepath string) (err error) {
	fset := token.NewFileSet()

	f, err := parser.ParseFile(fset, "", src, parser.ParseComments)
	if err != nil {
		return err
	}

	var errorVars []string
	var errorMapEntries []string
	var nodeToRemove ast.Node

	ast.Inspect(f, func(n ast.Node) bool {
		// Check if the node is a general declaration
		if genDecl, ok := n.(*ast.GenDecl); ok {
			// Check if the declaration is a variable declaration
			if genDecl.Tok == token.VAR {
				// Iterate through the specs in the declaration
				for _, spec := range genDecl.Specs {
					// Check if the spec is a value spec (variable spec)
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						// Check if the variable has the name we're looking for
						for _, name := range valueSpec.Names {
							if name.Name == "errDef" {
								// Check if there is an actual type attached
								if valueSpec.Type != nil {
									fmt.Println("Type is not nil")
								} else {
									nodeToRemove = genDecl // genDecl is the *ast.GenDecl node
									// The type might be inferred from the literal
									if len(valueSpec.Values) > 0 {
										if compositeLit, ok := valueSpec.Values[0].(*ast.CompositeLit); ok {
											for _, elt := range compositeLit.Elts {
												if keyValueExpr, ok := elt.(*ast.KeyValueExpr); ok {
													// Assuming the key is a basic literal and value is a composite literal
													if key, ok := keyValueExpr.Key.(*ast.BasicLit); ok {
														if value, ok := keyValueExpr.Value.(*ast.CompositeLit); ok {
															// Extract error name, which is the second element of the composite literal
															if len(value.Elts) >= 3 {
																if nameLit, ok := value.Elts[1].(*ast.BasicLit); ok {
																	errorName := strings.Trim(nameLit.Value, "\"") // Remove quotes from the name
																	camelCaseName := ConvertNameToCamelCase(errorName)

																	// Extract the error message
																	if messageLit, ok := value.Elts[2].(*ast.BasicLit); ok {
																		errorMessage := strings.Trim(messageLit.Value, "\"") // Remove quotes from the message

																		// Create variable declaration and map entry
																		errorVar := fmt.Sprintf("Err%s = Error{%s, \"%s\", \"%s\", nil}", camelCaseName, key.Value, errorName, errorMessage)
																		errorVars = append(errorVars, errorVar)
																		errorMapEntry := fmt.Sprintf("%s: Err%s,", key.Value, camelCaseName)
																		errorMapEntries = append(errorMapEntries, errorMapEntry)
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return true
	})

	if nodeToRemove != nil {
		// Assuming `f` is the *ast.File containing the AST
		for i, decl := range f.Decls {
			if decl == nodeToRemove {
				// Remove the declaration
				f.Decls = append(f.Decls[:i], f.Decls[i+1:]...)
				break
			}
		}
	}

	output, err := os.Create(destFilepath)
	if err != nil {
		Fatalf("Failed to create output file: %w", err)
	}
	defer output.Close()

	if err := format.Node(output, fset, f); err != nil {
		Fatalf("Could not format modified AST: %w", err)
	}

	output.WriteString("// Code generated by go generateor; DO NOT EDIT.")
	output.WriteString("// by calling go generate . in package root\n")
	output.WriteString("var (\n")
	for _, errorVar := range errorVars {
		output.WriteString("  " + errorVar + "\n")
	}
	output.WriteString(")\n\n")

	output.WriteString("var cerrors = map[returnValue]Error{\n")
	for _, entry := range errorMapEntries {
		output.WriteString("  " + entry + "\n")
	}
	output.WriteString("}\n")

	return nil
}
